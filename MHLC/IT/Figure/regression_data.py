

import numpy as np
from scipy.integrate import quad
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats

data0=np.loadtxt('data0.txt',delimiter=',')

plt.figure(1)
plt.scatter(data0[:,0],data0[:,1])


sns.set()

w=15.0
u=110.0 # note that here we use the speed in ft/s
tau1= 3.0
gamma= 1.0 # gamma will change the shape of the exponential distribution, which represents the influence of density
v4= 60.0
s0= 2500.0
p0= 0.5
dx= 55.0


L=4440.0
x= np.arange(0,L,1)


data0 = np.loadtxt('data0.txt',delimiter=',')


def phi1(x):
    v=40.0
    deltav=(L-x)/L*(v-10.0)
    pi1=deltav/75.0/tau1
    desire=pi1/u
    return desire

def phi_60(x):
    pi2 = np.exp(-x/(800.0*1.2))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_50(x):
    pi2 = np.exp(-x/(800.0*1.12))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_40(x):
    pi2 = np.exp(-x/(800.0*1.08))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_30(x):
    pi2 = np.exp(-x/(800.0*1.06))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_20(x):
    pi2 = np.exp(-x/(800.0*0.89))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_10(x):
    pi2 = np.exp(-x/(800.0*1.0))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def ratio(demand,v,coeff=1.0):
    '''
    this function implements the IT principle
    :param demand: the lane change demand from origin lane
    :param v: the target lane speed
    :return: the fraction of LC flow that can proceed
    the coffe is to adjust the priority of lane change demand from origin lane
    note here the through demand from target lane is always capacity which is 2500.0
    so the fraction can be estimated using the following function
    '''
    supply=150.0/(1/v+1/w)
    p=supply/(2500.0+demand)
    return min(1,coeff*p)


def mlc(dist,target_speed,coeff=1.0):
    '''
    the function will take in one argument, i.e. the distribution of mandatory lane changes along distance
    and return the output like the PDF and CDF of theoretical lane changes along the distance
    :param dist:
    :return:
    '''
    sending=[] # s1 means the list of sending flow at each cell
    s0=2500.0
    penetration = []
    pe = p0 =0.5
    pne = 1 - p0
    dmlc = []
    cum = []
    sum = 0
    simu=[]
    for i in range(70,1,-1):

    # s0 is the old sending flow from last time
    # s1 is the remaining sending flow after this time
    # pe is the penetration of exiting vehicles
    # pne is the penetration of non-exiting vehiclesl
    # lc1 is the real discretionary LC flow generated by poisson distribution
    # lc2 is the real mandatory LC flow generated by poisson distribution
    # quad is the integrating function along distance
        I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
        # print('the probability of discretionary lane changes during such a cell', I1[0])
        I2 = quad(dist, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
        # print('the probability of mandatory lane changes during such a cell', I2[0])
        # print('the fraction of LC flow', p)
        # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
        lc1=s0*pne*I1[0]/u # this is to generate the real discretionary lane change flow
        lc2=s0*pe*I2[0]/u# this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
        IT=ratio(lc2,target_speed,coeff) # the fraction of LC flow that can proceed, it's related to IT principle
        lc2=lc2*IT
        # lc2=max(np.random.poisson(lc2),s0*pe)
        # print('the fraction of preceeding LC flow is',IT)
        sum = sum + lc2 # this is to record the sum of exiting vehicles
        dmlc.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
        s1=s0-lc1-lc2 # this is to calculate the remaining sending flow, s1 means the remaining sending flow
        pe=(s0*pe-lc2)/s1 # this is update the penetration of exiting vehicles
        pne=1.0-pe
        # prob.append(phi2(x*(70-i)))
        sending.append(s1)
        penetration.append(pe)
        # we should do a Poisson distribution to generate the real flow
        cum.append(sum)
        s0=s1
    # after end the loop
    sending=sending[::-1] # we need to inverse the list, so the distance can actually start from 0 to 4000
    dmlc = dmlc[::-1]
    dmlc = np.array(dmlc)
    dmlc = dmlc/sum
    # print('the generated dmlc flow is',dmlc)
    penetration=penetration[::-1]
    # prob=prob[::-1]
    cum = cum[::-1]
    cum = np.array(cum)
    cum = cum/sum
    x = np.linspace(0,L,69)
    xvals = np.linspace(0, L, 500)
    # dmlc = np.interp(xvals, x, dmlc)
    ## here we would like to print the residual of the curve
    residual = np.interp(data0[:,0],x,dmlc)
    residual=np.absolute(residual)
    error_square=np.sum(residual)
    print('the sum of absolute error is',error_square)
    print('the residuals list is',residual)
    # note that here we have an interpolation function
    sending = np.interp(xvals, x, sending)
    penetration =np.interp(xvals, x, penetration)
    cum = np.interp(xvals, x, cum)
    return sending,dmlc,cum,penetration



# linewidth=2
xvals = np.linspace(0, L, 500)
# ## execute the different spatial distribution of mandatory lane changes
# sending_60,dmlc_60,cum_60,penetration_60 = mlc(phi_60,60.0,1.1)
# sending_50,dmlc_50,cum_50,penetration_50 = mlc(phi_50,50.0,1.1)
# sending_40,dmlc_40,cum_40,penetration_40 = mlc(phi_40,40.0,1.2)
# sending_30,dmlc_30,cum_30,penetration_30 = mlc(phi_30,30.0,1.2)
# sending_20,dmlc_20,cum_20,penetration_20 = mlc(phi_20,20.0,1.5)

print('search for the optimal parameter when target lane speed is 10 mi/h')
sending_10,dmlc_10,cum_10,penetration_10 = mlc(phi_10,10.0,2.0)


# simu_60 = mlc_simu(phi_60,60.0,1.1)
# simu_50 = mlc_simu(phi_50,50.0,1.1)
# simu_40 = mlc_simu(phi_40,40.0,1.2)
# simu_30 = mlc_simu(phi_30,30.0,1.2)
# simu_20 = mlc_simu(phi_20,20.0,1.5)
# simu_10 = mlc_simu(phi_10,10.0,2.0)





