# this is to implement the desire function and the IT principle

import numpy as np
from scipy.integrate import quad
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
from scipy import integrate

# sns.set()

w=15.0
u=110.0 # note that here we use the speed in ft/s
tau1= 3.0
gamma= 1.0 # gamma will change the shape of the exponential distribution, which represents the influence of density
v4= 60.0
s0= 2500.0
p0= 0.5
dx= 55.0


L=4440.0
x= np.arange(0,L,1)


data30 = np.loadtxt('data30.txt',delimiter=',')


def phi1(x):
    v=40.0
    deltav=(L-x)/L*(v-10.0)
    pi1=deltav/75.0/tau1
    desire=pi1/u
    return desire

def phi_60(x):
    pi2 = np.exp(-x/(800.0*1.2))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_50(x):
    pi2 = np.exp(-x/(800.0*1.12))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_40(x):
    pi2 = np.exp(-x/(800.0*1.08))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_30(x):
    pi2 = np.exp(-x/(800.0*1.0))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_20(x):
    pi2 = np.exp(-x/(800.0*0.89))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def phi_10(x):
    pi2 = np.exp(-x/(800.0*0.81))
    # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2
    return desire

def ratio(demand,v,coeff=1.0):
    '''
    this function implements the IT principle
    :param demand: the lane change demand from origin lane
    :param v: the target lane speed
    :return: the fraction of LC flow that can proceed
    the coffe is to adjust the priority of lane change demand from origin lane
    note here the through demand from target lane is always capacity which is 2500.0
    so the fraction can be estimated using the following function
    '''
    supply=150.0/(1/v+1/w)
    p=supply/(2500.0+demand)
    return min(1,coeff*p)


def mlc(dist,target_speed,coeff=1.0):
    '''
    the function will take in one argument, i.e. the distribution of mandatory lane changes along distance
    and return the output like the PDF and CDF of theoretical lane changes along the distance
    :param dist:
    :return:
    '''
    sending=[] # s1 means the list of sending flow at each cell
    s0=2500.0
    penetration = []
    pe = p0 =0.5
    pne = 1 - p0
    dmlc = []
    cum = []
    sum = 0
    simu=[]
    for i in range(70,1,-1):

    # s0 is the old sending flow from last time
    # s1 is the remaining sending flow after this time
    # pe is the penetration of exiting vehicles
    # pne is the penetration of non-exiting vehiclesl
    # lc1 is the real discretionary LC flow generated by poisson distribution
    # lc2 is the real mandatory LC flow generated by poisson distribution
    # quad is the integrating function along distance
        I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
        # print('the probability of discretionary lane changes during such a cell', I1[0])
        I2 = quad(dist, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
        # print('the probability of mandatory lane changes during such a cell', I2[0])
        # print('the fraction of LC flow', p)
        # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
        lc1=s0*pne*I1[0]/u # this is to generate the real discretionary lane change flow
        lc2=s0*pe*I2[0]/u# this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
        IT=ratio(lc2,target_speed,coeff) # the fraction of LC flow that can proceed
        lc2=lc2*IT
        # lc2=max(np.random.poisson(lc2),s0*pe)
        print('the fraction of preceeding LC flow is',IT)
        sum = sum + lc2 # this is to record the sum of exiting vehicles
        dmlc.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
        s1=s0-lc1-lc2 # this is to calculate the remaining sending flow, s1 means the remaining sending flow
        pe=(s0*pe-lc2)/s1 # this is update the penetration of exiting vehicles
        pne=1.0-pe
        # prob.append(phi2(x*(70-i)))
        sending.append(s1)
        penetration.append(pe)
        # we should do a Poisson distribution to generate the real flow
        cum.append(sum)
        s0=s1
    # after end the loop
    sending=sending[::-1] # we need to inverse the list, so the distance can actually start from 0 to 4000
    dmlc = dmlc[::-1]
    dmlc = np.array(dmlc)
    dmlc = dmlc/sum
    # print('the generated dmlc flow is',dmlc)
    penetration=penetration[::-1]
    # prob=prob[::-1]
    cum = cum[::-1]
    cum = np.array(cum)
    cum = cum/sum
    x = np.linspace(0,L,69)
    xvals = np.linspace(0, L, 500)
    dmlc = np.interp(xvals, x, dmlc)
    sending = np.interp(xvals, x, sending)
    penetration =np.interp(xvals, x, penetration)
    cum = np.interp(xvals, x, cum)
    return sending,dmlc,cum,penetration


def mlc_simu(dist,target_speed,coeff=1.0):
    '''
    the function will take in one argument, i.e. the distribution of mandatory lane changes along distance
    and return the output like the PDF and CDF of theoretical lane changes along the distance
    :param dist:
    :return:
    '''
    sending=[] # s1 means the list of sending flow at each cell
    s0=2500.0
    penetration = []
    pe = p0 =0.5
    pne = 1 - p0
    dmlc = []
    cum = []
    sum = 0
    simu=[]
    for i in range(70,1,-1):

    # s0 is the old sending flow from last time
    # s1 is the remaining sending flow after this time
    # pe is the penetration of exiting vehicles
    # pne is the penetration of non-exiting vehiclesl
    # lc1 is the real discretionary LC flow generated by poisson distribution
    # lc2 is the real mandatory LC flow generated by poisson distribution
    # quad is the integrating function along distance
        I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
        # print('the probability of discretionary lane changes during such a cell', I1[0])
        I2 = quad(dist, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
        # print('the probability of mandatory lane changes during such a cell', I2[0])
        # print('the fraction of LC flow', p)
        # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
        lc1=s0*pne*I1[0]/u # this is to generate the real discretionary lane change flow
        lc2=s0*pe*I2[0]/u# this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
        IT=ratio(lc2,target_speed,coeff) # the fraction of LC flow that can proceed
        lc2=lc2*IT
        lc2=min(np.random.poisson(lc2),s0*pe)
        print('the fraction of preceeding LC flow is',IT)
        sum = sum + lc2 # this is to record the sum of exiting vehicles
        dmlc.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
        s1=s0-lc1-lc2 # this is to calculate the remaining sending flow, s1 means the remaining sending flow
        pe=(s0*pe-lc2)/s1 # this is update the penetration of exiting vehicles
        pne=1.0-pe
        # prob.append(phi2(x*(70-i)))
        sending.append(s1)
        penetration.append(pe)
        # we should do a Poisson distribution to generate the real flow
        cum.append(sum)
        s0=s1
    # after end the loop
    dmlc = dmlc[::-1]
    dmlc = np.array(dmlc)
    print('the generated dmlc vehicles is',dmlc)
    # x = np.linspace(0,L,69)
    # xvals = np.linspace(0, L, 500)
    # dmlc = np.interp(xvals, x, dmlc)
    return dmlc # the list of number of dmlc of all cells


linewidth=2
xvals = np.linspace(0, L, 500)
## execute the different spatial distribution of mandatory lane changes
sending_60,dmlc_60,cum_60,penetration_60 = mlc(phi_60,60.0,1.1)
sending_50,dmlc_50,cum_50,penetration_50 = mlc(phi_50,50.0,1.1)
sending_40,dmlc_40,cum_40,penetration_40 = mlc(phi_40,40.0,1.2)
sending_30,dmlc_30,cum_30,penetration_30 = mlc(phi_30,30.0,1.2)
sending_20,dmlc_20,cum_20,penetration_20 = mlc(phi_20,20.0,1.5)
sending_10,dmlc_10,cum_10,penetration_10 = mlc(phi_10,10.0,2.0)


simu_60 = mlc_simu(phi_60,60.0,1.1)
simu_50 = mlc_simu(phi_50,50.0,1.1)
simu_40 = mlc_simu(phi_40,40.0,1.2)
simu_30 = mlc_simu(phi_30,30.0,1.2)
simu_20 = mlc_simu(phi_20,20.0,1.5)
simu_10 = mlc_simu(phi_10,10.0,2.0)



f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)

ax1.set_title('The exponential-distributed desire of mandatory lane changes')
ax1.plot(xvals, phi_60(xvals),color="#9b59b6", lw=linewidth) # gamma= 1.5
ax1.plot(xvals, phi_50(xvals),color="#3498db", lw=linewidth) # gamma= 1.5
ax1.plot(xvals, phi_40(xvals),color="#95a5a6", lw=linewidth) # gamma= 1.5
ax1.plot(xvals, phi_30(xvals),color="#e74c3c", lw=linewidth) # gamma= 1.5
ax1.plot(xvals, phi_20(xvals),color="#34495e", lw=linewidth) # gamma= 1.5
ax1.plot(xvals, phi_10(xvals),color="#2ecc71", lw=linewidth) # gamma= 1.5
ax1.legend(['50-60 mi/h','40-50 mi/h','30-40 mi/h','20-30 mi/h','10-20 mi/h','0-10 mi/h'], loc='upper right')
ax1.set_xlabel('Distance to gore (ft)',fontsize = 12)
ax1.set_ylabel('Probability', fontsize = 12)

index=np.arange(69)
ax2.set_title('The number of mandatory lane changes')
ax2.set_ylabel('veh', fontsize=12)
interval = 0.6
bar_width = 0.4
alpha_value= 1.0
ax2.bar(index, simu_60, bar_width, alpha= alpha_value, color="#9b59b6")

ax2.bar(index+bar_width, simu_10, bar_width, alpha= alpha_value, color="#2ecc71")
ax2.legend(['50-60 mi/h','0-10 mi/h'], loc='upper right')
ax2.set_xlabel('Cell Number',fontsize = 12)
ax2.set_ylabel('Vehs', fontsize = 12)


ax3.set_xlabel('Distance to gore (ft)', fontsize=12)
ax3.set_ylabel('Probability density', fontsize=12)

ax3.set_title('The PDF of spatial distribution of mandatory lane changes')
ax3.plot(xvals, dmlc_60, color="#9b59b6", lw=linewidth)
ax3.plot(xvals, dmlc_50, color="#3498db", lw=linewidth)
ax3.plot(xvals, dmlc_40, color="#95a5a6", lw=linewidth)
ax3.plot(xvals, dmlc_30, color="#e74c3c", lw=linewidth)
ax3.plot(xvals, dmlc_20, color="#34495e", lw=linewidth)
ax3.plot(xvals, dmlc_10, color="#2ecc71", lw=linewidth)
# ax3.scatter(data30[:,0],data30[:,1])
# deg=3
# z=np.polyfit(data30[:,0],data30[:,1],deg)
# ax3.plot(xvals,z[0]*xvals**3+z[1]*xvals**2+z[2]*xvals**1+z[3]*xvals**0)
# chris=lambda x:z[0]*x**3+z[1]*x**2+z[2]*x**1+z[3]*x**0
# print('integrate value is',integrate.quad(chris,0,4400))

# ax3.legend(['50-60 mi/h','40-50 mi/h','30-40 mi/h','20-30 mi/h','10-20 mi/h','0-10 mi/h'], loc='upper right')



ax4.set_title('The CDF of spatial distribution of mandatory lane changes')
ax4.set_xlabel('Distance to gore (ft)', fontsize=12)
ax4.set_ylabel('Probability', fontsize=12)
ax4.plot(xvals, cum_60,color="#9b59b6",lw=linewidth)
ax4.plot(xvals, cum_50,color="#3498db",lw=linewidth)
ax4.plot(xvals, cum_40,color="#95a5a6",lw=linewidth)
ax4.plot(xvals, cum_30,color="#e74c3c",lw=linewidth)
ax4.plot(xvals, cum_20,color="#34495e",lw=linewidth)
ax4.plot(xvals, cum_10,color="#2ecc71",lw=linewidth)
ax4.legend(['50-60 mi/h','40-50 mi/h','30-40 mi/h','20-30 mi/h','10-20 mi/h','0-10 mi/h'], loc='upper right')


# sns.axes_style("darkgrid")
plt.show()



