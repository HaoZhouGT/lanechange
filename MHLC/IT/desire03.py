import numpy as np
from scipy.integrate import quad
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
# sns.axes_style("darkgrid")




u=110.0 # note that here we use the speed in ft/s
tau1= 3.0
gamma= 1.0 # gamma will change the shape of the exponential distribution, which represents the influence of density
v4= 60.0
s0= 2500
p0= 0.5
dx= 55.0


L=4440.0
x= np.arange(0,L,1)


def sending(x):
    flow = 2500*x/L
    return flow


def phi1(x):
    v=40.0
    deltav=(L-x)/L*(v-10.0)
    pi1=deltav/75.0/tau1
    desire=pi1/u
    return desire

def phi2(x):
    pi2=np.exp(-x/(800*gamma)) # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2/u
    return desire

def pi2_1(x):
    prob = np.exp(-x / (800 * 1.5))
    return prob

def pi2_2(x):
    prob = np.exp(-x / (800 * 1.2))
    return prob

def pi2_3(x):
    prob = np.exp(-x / (800 * 1.0))
    return prob

s=[]
penetration=[]
pe=p0
pne=1-p0
dmlc=[]
prob=[]
cum=[]
sum=0
dmlc_theo=[]


for i in range(70,1,-1):
    '''
    s0 is the old sending flow from last time
    s1 is the remaining sending flow after this time
    pe is the penetration of exiting vehicles
    pne is the penetration of non-exiting vehiclesl
    lc1 is the real discretionary LC flow generated by poisson distribution 
    lc2 is the real mandatory LC flow generated by poisson distribution
    '''
    # quad is the integrating function along distance
    I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
    print('the probability of discretionary lane changes', I1[0])
    I2 = quad(phi2, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
    print('the probability of mandatory lane changes', I2[0])
    # print('the fraction of LC flow', p)
    # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
    lc1=np.random.poisson(s0*pne*I1[0]) # this is to generate the real discretionary lane change flow
    lc2=np.random.poisson(s0*pe*I2[0]) # this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
    lc2_theo=s0*pe*I2[0]
    dmlc.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
    dmlc_theo.append(lc2_theo)
    s1=s0-lc1-lc2 # this is to calculate the remaining through flow
    pe=(s0*pe-lc2)/s1
    pne=1.0-pe
    # prob.append(phi2(x*(70-i)))
    s.append(s1)
    penetration.append(pe)
    # we should do a Poisson distribution to generate the real flow
    cum.append(sum)
    sum=sum+lc2
    s0=s1

#
# cmap = plt.get_cmap("tab20c")
# outer_colors = cmap(np.arange(3)*4)
# inner_colors = cmap(np.array([1, 2, 5, 6, 9, 10]))



s=s[::-1] # we need to inverse the list, so the distance can actually start from 0 to 4000
dmlc = dmlc[::-1]
dmlc=np.array(dmlc)
print('the generated dmlc flow is',dmlc)
barx = np.linspace(0,L,69)

penetration=penetration[::-1]
# prob=prob[::-1]
cum =cum[::-1]
f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
x = np.linspace(0,L,69)
xvals = np.linspace(0, L, 500)
dmlc_1 = np.interp(xvals, x, dmlc)
s = np.interp(xvals, x, s)
penetration=np.interp(xvals, x, penetration)
# prob = np.interp(xvals, x, prob)
cum = np.interp(xvals, x, cum)


ax1.set_title('The exponential-distributed desire of mandatory lane changes')
ax1.plot(xvals, pi2_1(xvals),sns.xkcd_rgb["pale red"], lw=3)
# this is to plot the desire function controlled by gamma (representing density)



ax2.set_title('The sending flow along distance to gore')
ax2.set_ylabel('flow(veh/h)', fontsize=10)
ax3.set_xlabel('distance to gore (ft)', fontsize=10)
ax2.plot(xvals, s, sns.xkcd_rgb["medium green"], lw=3)
ax3.set_title('The number of mandatory lane changes by simulation')
ax3.set_ylabel('vehicles', fontsize=10)
# ax3.plot(xvals, dmlc_1, sns.xkcd_rgb["denim blue"], lw=3)
ax3.bar(barx, dmlc)
ax4.set_title('The cumulative number of mandatory lane changes')
ax4.set_ylabel('vehicles', fontsize=10)
ax4.set_xlabel('distance to gore (ft)', fontsize=10)
ax4.plot(xvals, cum, color="#9b59b6",lw=3)
plt.show()



