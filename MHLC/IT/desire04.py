import numpy as np
from scipy.integrate import quad
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

u=110.0 # note that here we use the speed in ft/s
tau1= 3.0
gamma= 1.0 # gamma will change the shape of the exponential distribution, which represents the influence of density
v4= 60.0
s0= 2500
p0= 0.5
dx= 55.0


L=4440.0
x= np.arange(0,L,1)


def sending(x):
    flow = 2500*x/L
    return flow


def phi1(x):
    v=40.0
    deltav=(L-x)/L*(v-10.0)
    pi1=deltav/75.0/tau1
    desire=pi1/u
    return desire

def phi2_1(x):
    pi2=np.exp(-x/(800*gamma)) # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2/u
    return desire

def pi2_1(x):
    prob = np.exp(-x / (800 * 1.5))
    return prob

def pi2_2(x):
    prob = np.exp(-x / (800 * 1.2))
    return prob

def pi2_3(x):
    prob = np.exp(-x / (800 * 1.0))
    return prob

s_1=[]
penetration_1=[]
pe_1=p0
pne_1=1-p0
dmlc_1=[]
prob_1=[]
cum_1=[]
sum_1=0


for i in range(70,1,-1):
    '''
    s0 is the old sending flow from last time
    s1 is the remaining sending flow after this time
    pe is the penetration of exiting vehicles
    pne is the penetration of non-exiting vehiclesl
    lc1 is the real discretionary LC flow generated by poisson distribution 
    lc2 is the real mandatory LC flow generated by poisson distribution
    '''
    # quad is the integrating function along distance
    I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
    print('the probability of discretionary lane changes', I1[0])
    I2 = quad(phi2_1, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
    print('the probability of mandatory lane changes', I2[0])
    # print('the fraction of LC flow', p)
    # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
    lc1=np.random.poisson(s0*pne_1*I1[0]) # this is to generate the real discretionary lane change flow
    lc2=np.random.poisson(s0*pe_1*I2[0]) # this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
    dmlc_1.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
    s1_1=s0-lc1-lc2 # this is to calculate the remaining through flow
    pe_1=(s0*pe_1-lc2)/s1_1
    pne_1=1.0-pe_1
    # prob.append(phi2(x*(70-i)))
    s_1.append(s1_1)
    penetration_1.append(pe_1)
    # we should do a Poisson distribution to generate the real flow
    cum_1.append(sum_1)
    sum_1=sum_1+lc2
    s0=s1_1


s=s_1[::-1] # we need to inverse the list, so the distance can actually start from 0 to 4000
dmlc_1 = dmlc_1[::-1]
print('the generated dmlc flow is',dmlc_1)
penetration_1=penetration_1[::-1]
# prob=prob[::-1]
cum_1 =cum_1[::-1]
x = np.linspace(0,L,69)
xvals = np.linspace(0, L, 500)
dmlc_1 = np.interp(xvals, x, dmlc_1)
s_1 = np.interp(xvals, x, s)
penetration_1=np.interp(xvals, x, penetration_1)
# prob = np.interp(xvals, x, prob)
cum_1 = np.interp(xvals, x, cum_1)



'''
the following code implements another density case, where gamma is 1.2
'''

def phi2_2(x):
    pi2=np.exp(-x/(800*1.2)) # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2/u
    return desire


s0=2500.0
p0=0.5
s_2=[]
penetration_2=[]
pe_2=p0
pne_2=1-p0
dmlc_2=[]
prob_2=[]
cum_2=[]
sum_2=0


for i in range(70,1,-1):
    '''
    s0 is the old sending flow from last time
    s1 is the remaining sending flow after this time
    pe is the penetration of exiting vehicles
    pne is the penetration of non-exiting vehiclesl
    lc1 is the real discretionary LC flow generated by poisson distribution 
    lc2 is the real mandatory LC flow generated by poisson distribution
    '''
    # quad is the integrating function along distance
    I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
    print('the probability of discretionary lane changes', I1[0])
    I2 = quad(phi2_2, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
    print('the probability of mandatory lane changes', I2[0])
    # print('the fraction of LC flow', p)
    # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
    lc1=np.random.poisson(s0*pne_2*I1[0]) # this is to generate the real discretionary lane change flow
    lc2=np.random.poisson(s0*pe_2*I2[0]) # this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
    dmlc_2.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
    s1_2=s0-lc1-lc2 # this is to calculate the remaining through flow
    pe_2=(s0*pe_2-lc2)/s1_2
    pne_2=1.0-pe_2
    # prob.append(phi2(x*(70-i)))
    s_2.append(s1_2)
    penetration_2.append(pe_2)
    # we should do a Poisson distribution to generate the real flow
    cum_2.append(sum_2)
    sum_2=sum_2+lc2
    s0=s1_2


s_2=s_2[::-1] # we need to inverse the list, so the distance can actually start from 0 to 4000
dmlc_2 = dmlc_2[::-1]
print('the generated dmlc flow is',dmlc_2)
penetration_2=penetration_2[::-1]
# prob=prob[::-1]
cum_2 =cum_2[::-1]
f, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
x = np.linspace(0,L,69)
xvals = np.linspace(0, L, 500)
dmlc_2 = np.interp(xvals, x, dmlc_2)
s_2 = np.interp(xvals, x, s_2)
penetration_2=np.interp(xvals, x, penetration_2)
# prob = np.interp(xvals, x, prob)
cum_2 = np.interp(xvals, x, cum_2)






## the following code implements the third density case


'''
the following code implements another density case, where gamma is 0.8
'''

def phi2_3(x):
    pi2=np.exp(-x/(800*0.8)) # actually the tau2 denotes the changing rate of exponential, we can interpret that tau2
    # the shape of exponential distribution influence the rate of probability increase along the distance
    # actually the shape should represent the effect on target lane density
    desire=pi2/u
    return desire


s0=2500.0
p0=0.5
s_3=[]
penetration_3=[]
pe_3=p0
pne_3=1-p0
dmlc_3=[]
prob_3=[]
cum_3=[]
sum_3=0


for i in range(70,1,-1):
    '''
    s0 is the old sending flow from last time
    s1 is the remaining sending flow after this time
    pe is the penetration of exiting vehicles
    pne is the penetration of non-exiting vehiclesl
    lc1 is the real discretionary LC flow generated by poisson distribution 
    lc2 is the real mandatory LC flow generated by poisson distribution
    '''
    # quad is the integrating function along distance
    I1 = quad(phi1, (i-1)*dx, i*dx) # fraction of discretionary LC flow from i*dx to (i+1)*dx
    print('the probability of discretionary lane changes', I1[0])
    I2 = quad(phi2_3, (i-1)*dx, i*dx) # fraction of mandatory LC flow from i*dx to (i+1)*dx
    print('the probability of mandatory lane changes', I2[0])
    # print('the fraction of LC flow', p)
    # here we should generate the real LC flow by Poisson distribution,using the probability as the mean value
    lc1=np.random.poisson(s0*pne_3*I1[0]) # this is to generate the real discretionary lane change flow
    lc2=np.random.poisson(s0*pe_3*I2[0]) # this is to generate the expected mandatory lane change flow, still it needs a poisson distribution
    dmlc_3.append(lc2) # in simulation, the rate and probability is for the average value, not for the real numbers. You need PP
    s1_3=s0-lc1-lc2 # this is to calculate the remaining through flow
    pe_3=(s0*pe_3-lc2)/s1_3
    pne_3=1.0-pe_3
    # prob.append(phi2(x*(70-i)))
    s_3.append(s1_3)
    penetration_3.append(pe_3)
    # we should do a Poisson distribution to generate the real flow
    cum_3.append(sum_3)
    sum_3=sum_3+lc2
    s0=s1_3


s_3=s_3[::-1] # we need to inverse the list, so the distance can actually start from 0 to 4000
dmlc_3 = dmlc_3[::-1]
print('the generated dmlc flow is',dmlc_3)
penetration_3=penetration_3[::-1]
# prob=prob[::-1]
cum_3 =cum_3[::-1]

x = np.linspace(0,L,69)
xvals = np.linspace(0, L, 500)
dmlc_3 = np.interp(xvals, x, dmlc_3)
s_3 = np.interp(xvals, x, s_3)
penetration_3=np.interp(xvals, x, penetration_3)
# prob = np.interp(xvals, x, prob)
cum_3 = np.interp(xvals, x, cum_3)

linewidth=2

ax1.set_title('The exponential-distributed desire of mandatory lane changes')
ax1.plot(xvals, pi2_1(xvals),sns.xkcd_rgb["pale red"], lw=linewidth) # gamma= 1.5
# this is to plot the desire function controlled by gamma (representing density)
ax1.plot(xvals, pi2_2(xvals),sns.xkcd_rgb["medium green"], lw=linewidth) # gamma = 1.2
ax1.plot(xvals, pi2_3(xvals),sns.xkcd_rgb["denim blue"], lw=linewidth) # gamma= 1.0



ax2.set_title('The sending flow along distance to gore')
ax2.set_ylabel('flow(veh/h)', fontsize=10)
ax2.plot(xvals, s_1, sns.xkcd_rgb["pale red"], lw=linewidth)
ax2.plot(xvals, s_2, sns.xkcd_rgb["medium green"], lw=linewidth)
ax2.plot(xvals, s_3, sns.xkcd_rgb["denim blue"], lw=linewidth)



ax3.set_xlabel('distance to gore (ft)', fontsize=10)
ax3.set_title('The number of mandatory lane changes by simulation')
ax3.set_ylabel('vehicles', fontsize=10)
ax3.plot(xvals, dmlc_1, sns.xkcd_rgb["pale red"], lw=linewidth)
ax3.plot(xvals, dmlc_2, sns.xkcd_rgb["medium green"], lw=linewidth)
ax3.plot(xvals, dmlc_3, sns.xkcd_rgb["denim blue"], lw=linewidth)



ax4.set_title('The cumulative number of mandatory lane changes')
ax4.set_ylabel('vehicles', fontsize=10)
ax4.set_xlabel('distance to gore (ft)', fontsize=10)
ax4.plot(xvals, cum_1,sns.xkcd_rgb["pale red"],lw=linewidth)
ax4.plot(xvals, cum_2,sns.xkcd_rgb["medium green"],lw=linewidth)
ax4.plot(xvals, cum_3,sns.xkcd_rgb["denim blue"],lw=linewidth)

# color="#9b59b6"

sns.axes_style("darkgrid")

plt.show()



